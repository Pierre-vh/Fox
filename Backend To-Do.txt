Work on this part of the project has just started, so expect the BC, BCGen and VM parts
to be incomplete for a bit of time. 

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA

---- Initial Preparation and Scaffolding ---- DONE ----
  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ---- DONE ----
  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
  -> Implement comparisons & logic operators (Done)

---- Implementation of control flow ---- DONE ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of casting opcodes ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of basic CodeGen ----
  -> Scaffolding (Done)
  -> InstructionBuilder's buffer can be taken (Done)
  -> Bytecode Dumper (Done)
  -> RegisterAllocator & RegisterValue (Done)
  -> Basic CodeGen of simple integral expressions (only ints, bool and char) (Done)
  -> VMModule (Done)
  -> Scaffoldign of BCGen entry points (Done)
  -> Codegen of local variables (Done)
  -> Code review in Register.hpp/.cpp and BCGenDecl (Done)
  -> BCModule::instr_iterator (Done)
  -> BCBuilder Update (Done)
  -> Add index when dumping instructions, e.g. [42] StoreSmallInt 3 50 (Done)
  -> BCModule/BCModuleBuilder rework part 1(Done)
  -> CodeGen of Statements except ReturnStmt (Done)
  > BCModule/BCModuleBuilder rework part 2 : Functions (Done)

  -> Constants & Constant Table
    -> BCModule (Done)
    -> BCGen (Done)
    -> Instructions + VM support (Done)

  -> BCGen of Double literals & expressions (Done)

  -> Destination register for ExprGenerator (Done)

  -> BCGen of Assignements (Done)

  -> Codegen of functions & return statements
    -> RegisterAllocator Support for ParamDecl (Done)
    -> BCGen support for ParamDecl: Prologue, DeclRef, etc (Done)
    -> BCFunction: PCM (Done)
    -> VM Instructions (LoadFunc, Call and CallVoid) (Done)
    -> Add unused parameters detection in semantic analysis (Done)
    -> RegisterAllocator should ignore unused parameters (Done)
    -> FuncDecl::numUsedParams() (Done)
    -> BCGen::getBCFunction(FuncDecl*) (Done)
    -> CallExpr compilation (Done)

---- Implementation of Builtin Functions ----
    -> Basic Scaffolding (done)
    -> BuiltinFuncDecl (Done)
    -> ASTContext::lookupBuiltin (Done)
    -> Name Binding/Sema (Done)
    -> VM
      -> CallBuiltin (Done)
      -> FunctionRef (Done)
      -> LoadBuiltin instruction + callFunc handling (Done)
    -> BCGen (Done)
    -> VM (LoadBuiltin + callFunc update) & unit tests (Done)
    -> Review the code I wrote for builtins (Done)
    -> Unit test for Ambiguous Builtins (Done)

---- Implementation of Object types ----
  Note: At first, objects won't be freed. I'll use a leak-forever allocator (LinearAllocator).
    GC will come later when the language is officially "feature-complete", because writing a good, reliable
    GC takes time and I'll probably write a better one with the full design of the language implemented.

  -> Common "Object" base (Done)
  -> Strings
    -> StringObject (Done)
    -> Finish StringObject's implementation
  -> VM instructions (Done)
    -> NewString (Done)
    -> LoadStringK (Done)
    -> Test! (Done)
  -> StringLiteralExpr BCGen (Done)
  -> Builtins
    -> StringObject* support (Done)
    -> Add all string builtins that I need
      -> toString() for Int, Double, Bool, Char (Done)
  -> Compile the 'Concat' BinOp in BCGenExpr
    -> string+string (Done)
    -> handle chars (change the thunk depending on the type) (Done)
  -> Default-init variables based on their type (Done)
  -> Implement string interface in full (done)
  -> Arrays 
    -> Scaffolding: use std::vector for now (Done)
    -> Add "isObjectArray" bool to ArrayObject + "isObjectArray" + ctor arg
      (needed for GC)
    -> Operations & Builtins
      > Array creation: NewValueArray and NewObjectArray instructions
        -> <dest> <num_start_elems>
      > ArrayLiteral compilation
        -> LoadBuiltin once + Load the array
        -> Always compile the arg to the following register
        -> Call builtin
            e.g. code would be (for [1, 2, 3])
              NewValueArray 0 3               // create the new array with 3 reserved elements
              LoadBuiltinFunc 1 arrayPushBack // load the push_back builtin
              Copy 0 1                        // use the array as first argument
              StoreSmallInt 2 1               // compile first element
              CallVoid 0                      // push it
              StoreSmallInt 2 2               // compile first element
              CallVoid 0                      // push it
              StoreSmallInt 2 3               // compile first element
              CallVoid 0                      // push it
      > Subscripts
      > Array-related builtins
    -> Tests

---- Getting feature-complete (with the current feature set) ----
  -> Entry point detection (basic, just the function called 'main' with a '() -> int' signature for now. Update the "run" tests as well)
      -> Store the entry point in the ASTContext (FuncDecl* ASTContext::getEntryPoint() + corresponding setter)
  -> Global Variables
  -> Better (but not yet final) error management system for the VM (at least one that doesn't use assert)
    -> Used when dividing by zero, getChar out of range/negative, etc.
     -> Add debug info only for risky instructions (calls, division) (Instruction n° -> SourceRange)      
  -> Allow the register stack to grow
  -> Properly diagnose maximum register pressure exceeded + max jump ranges exceeded
    > e.g. When the RegisterAllocator runs out of registers, it should call a handler 
  -> Test/Document as much as possible.
  -> Rewrite Wiki

---- Implementing the GC ----
  -> Objects should behave like a linked list
  -> Change my VM allocator
    -> Options are:
      -> new/delete + keep a pointer to the first object of the list
      -> LinearAllocator (but more complicated since the GC would need to be a moving one)
  -> Make String and Vector trivially destructible (if needed -> if I use LinearAllocator/a custom heap)
    -> String: use trailing objects
    -> Vector: use a separate "Storage" object (ArrayStorageObject
    
  -> Add TypeBase::isReference() -> true for string, array. ignores LValues too.

  -> "ReferenceMap" (Safe points) to track register that contain references.
    -> Implemented in the RegisterAllocator.
      -> I'll need to track which registers are holding references. The easiest way to do that would be to add a method to
         RegisterValue "markAsReference" that marks that Register as holding a reference (only for temporaries). 
         initVar would deduce that using the variable's type probably.
         When allocating a new register, always clear the corresponding bit in the reference map.
      -> getReferenceMap()

  -> Add storage of Reference Maps in BCFunction

  -> Generate Reference Maps when I do stuff that allocates data and may trigger a collection, or when
     the function "gives up" control in some way.
    -> Instantiating an array or a string, either through a literal or variable declaration
    -> Doing a call
    -> etc.?

  -> Proper call stack in the VM that keeps track of called BCFunctions

  -> ObjectVisitor

  -> GC: Mark and Sweep with colored objects. Non-generational/non-compacting at first
    -> Should be fairly straightforward: when collecting, walk the root set using the reference map as a guide.
    -> Color objects
    -> Clear all non-visited objects.

---- Other To-Dos ----
  -> Implement a Sethi-Ullman -like algorithm to decide the evaluation order
      of subexpressions (to make regalloc a bit more efficient)

  -> Potentially add a way of skipping 'useless' expressions on a case-by-case
      basis. 
      e.g. don't compile a 'Unary Not -> Unary Not -> Expr', just compile expr.
      I need to see if there's more of them and if it'd be worthwhile to implement such 
      a feature.

  -> Add a RegisterAllocator enableLogging option to emit logs about 
      register allocation, such as "Assignated Register X to Var 'foo' 0xABCDEF"
      or, upon death, emit the total of registers used, something like that.
      Add a "-log-regalloc" option and use write FileCheck tests based on that option.

  -> Properly diagnose out of range jumps in BCGen::StmtGenerator::calculateJumpOffset
    -> Same as diagnosing register pressure exceeded -> diagnostic like "'if' statement too complex to be compiled: reduce the amount of code contained inside it"
   
  -> Something that bothers me a bit is that I don't check my builtin calls. I simply emit them