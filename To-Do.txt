Moonshot Project To-do List.
	> ASTUnit : Represents a source file, contains declarations. (Done)
	> IdentifierTable & IdentifierInfo (Done)
	> ASTContext (Done)
	> Move stuf to /Fox/Basic (Done)
	> ASTContext : Types (Done)
	> New type system & deletion of /Common/Types (Done!)
	> Replace strings in the AST by IdentifierInfo* pointers (Done)	
	> ParsingResult rework (Done)
	> AST Improvements (Done)
	> Add ASTContext,parser & ast support for arrays types & Array literals. (Done)
	> Parser recovery improvements part 1(Done)
	> Parser recovery improvements part 2 (Done)
	> Parser recovery improvements part 3 : Reworked it entirely again! (Done)
	> Parsing Result Rework & Parser Improvements Part 4 : Final part (Done)
	> Create a "DeclarationRecorder", which is a wrapper around a std::multimap<IdentifierInfo*,ASTNamedDecl*> (Done)
	> Parser support for DeclRecorder with a RAIIContext object. (Done)
	> UniquePtrVector & DereferenceIterators + Minimizing interaction with unique pointers for AST Visitors(Done)
	> Major AST "Cleanup" in preparation for Visitor pattern rework (Done)
	> Write more Unit tests (Done)
	> Visitor system rework (Done)
	> Delete old ASTVisitor & Dumper  (Done)
	> Rewrite dumper under the new system	(Done)
	> Make "MapDataIterator" work (Done)
	> ASTDumper overhaul (Done)
	> Write tests for the new visitor system (I'll do more when needed)
	> Sourceloc & SourceManager system (Done)
	> Update lexer/token to add a sourcerange/loc to every single token (Done)
	> Update the Parser so it can return more SourceLoc info. (Done)
	> Update the AST so all nodes have a sourceloc/range too wherever needed. (Done)
	> Write Decl Locs Test (Done)
	> First AST Code Review (Done)
	> Remove "Fake" Recovery nodes in the AST and find a proper, better solution to this problem. (Done)
	> Update Diagnostics & DiagnosticsEngine to support SourceRange/SourceLoc (Done)
	> Namespace/Name change (Done)
	> Delete the Context (Done)
	> Update Lexer to use the DiagnosticEngine (Done)

	> Update Parser to use DiagnosticEngine + ParserDiagnostics Rework (Next)	
		> Stop the errorUnexpected spam (remove it entirely in favor of more precise error messages)
		> errorExpected : Switch to a "before token" instead of "after token"
			> Before the curtok (curtok is the place the error is for the report function)
				> (gcc-style messages) e.g. "Expected ';' before '}' token"
			> If no curtok (eof), use a special "at end of input" variant message and place the error caret at the last known token
				> e.g. "Expected ';' at end of input"
		> Also, create more variant of functions. All of them will return a Diagnostic object.
			> reportError(DiagID) // For generic error reporting
			> errorExpected(diagID)
			> expectedSemi(After Decl/Stmt/Expr, but how to pass the arg? String? Enum?)
			> expectedBracket(SignType) (for round/curly/square brackets)
			> expectedStmt()
			> expectedExpr()
			This will leave me more room in the future to improve specific error messages (e.g show the opening bracket in expectedBracket)
			Most of them won't take any additional args, unless needed.

	> Small update to SourceManager:
		Rename SourceManager.hpp/.cpp to Source.hpp/.cpp
		Rework the PreciseLoc algorithm : cache a "line table" and use it
			> std::map would work, just use the lower_bound to find the line and that's it.
		Also, add a method to return a full line of text for a given SourceLoc "getSourceLine"

	> Add classof operators to the AST (will be useful for testing if a class is a derived/base of without dynamic_cast)

	> Write the Remaining tests needed:
		> Write Stmt & Expr Loc Tests
			> Try to cover most cases shortly, maybe 2 or 3 max test per node.
			> Probably don't use a file, just do SetUp("<code goes here>"")w
		> classof tests
		> SourceManager "getSourceLine" test

	// Move to 0.3.0 & Sync with Master
	QOL:
		> Implement the "Caret" 
			>	The DiagnosticConsumer should always try to retrieve the line where the error happened, displaying '^^^^' under the place wherethe error is.
				> Implement that in the DiagnosticConsumer class in a protected function that the derived classes can use. (e.g. "getOriginalSourceLine(SourceLoc)")

		> Add a "Casting.h" file with wrappers around dynamic_cast, and utility functions that takes advantage of "classof"
			> Goal : If I move to RTTI-less casts later, I'll just need to change the implementation, instead of having to refactor a lot of code.
				> e.g. "fox_cast", "fox_isa"
				> Use the LLVM dyn_cast implementation as a guide.

		> Lexer Rework (Exact time to be decided, might come before/after Semantic Analysis)
			> Make the Lexer & Parser tightly coupled. The Parser itself should call the Lexer to Lex a token. (no more storage in a vector)
				> This will require the Parser or Lexer to have a caching mechanism, and use "cached" token when backtracking is required.
				> the "createParserStateBackup" functions will be removed, and replaced with a call to the lexer similar to "lexer_.backtrack(x)"
			> Stop using a DFA. Use a proper grammar with a recursive descent technique
			  and a config file (.def) to register valid terminals

	FEATURE:
		> Semantic Analysis
			> ASTValidator
			> Semantic Analysis should check for each node it's validity using the ASTValidator.
		      a typical Sema function should look like this for almost every node. The  proper analysis is then done by the Decl/Stmt/Expr checker.
			  (e.g. for a Decl) 
			  if(!Validator.visit(node))
				{
					diagnoseIncompleteDecl(node);
					return;
				}
			  
			  DeclChecker.visit(node);
					
