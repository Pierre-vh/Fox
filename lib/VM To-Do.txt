Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

  Ideas:
    -> Maybe add labels to instructions, so they can be more expressive?
      (e.g. we can have "dest lhs rhs" instead of "arg0 arg1 arg2")
      -> See if it's worth it.

    -> a file with several typedefs (in a "vm" namespace maybe) for:  
        opcode_t (std::uint8_t)
        regnum_t (std::uint8_t)
        instr_int_t (std::uint32_t)
        This will simplify some code in the VM and Instruction.def file

    -> Implement a Sethi-Ullman -like algorithm to decide the evaluation order
       of subexpressions to be a bit more register-efficient.

    -> Potentially add a way of skipping 'useless' expressions on a case-by-case
       basis. 
       e.g. don't compile a 'Unary Not -> Unary Not -> Expr', just compile expr.
       I need to see if there's more of them and if it'd be worthwhile to implement such 
       a feature.

---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators
    -> Declare opcodes (Done)
    -> Implement (Done)
    -> Test (Done)

---- Implementation of control flow ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of casting opcodes ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of basic CodeGen ----
  -> Scaffolding (Done)
  -> InstructionBuilder's buffer can be taken (Done)
  -> Bytecode Dumper (Done)
  -> Registers.hpp
    -> RegisterAllocator (Currently)
    -> RegisterValue (Done)
  -> Basic CodeGen of simple integral expressions : only compile time constant ops involving
       ints. (Now)
      - Binary Expr : Ints done
      - CastExpr      (Done)
      - UnaryExpr     (Done)
      -> Write FileCheck tests (Done)
      -> Make CodeGen more robust. It should support LValues without a problem. (Done)

  -> VMModule (Done)

  -> Scaffoldign of BCGen entry points (Done)

  -> Codegen of local variables (Done)
 
  -> Code review in Register.hpp/.cpp and BCGenDecl (Next)
      Eliminate redundancy, rewrite comments, etc.

   -> tryReuseRegister should, instead of moving the register, use a method like
      "regAlloc.recycleRegister(reg)", so the register allocator is notified of
      what's happening.

  -> Add a RegisterAllocator enableLogging option to emit logs about 
     register allocation, such as "Assignated Register X to Var 'foo' 0xABCDEF"
     or, upon death, emit the total of registers used, something like that.
     Add a "-log-regalloc" option and use write FileCheck tests based on that option.

  -> Write more BCGen test related to vardecls

  -> CodeGen of Statements

  -> Constants & Constant Table

  -> Implement the rest of the arithmetic bits of ExprGenerator:
    -> Double & Double operations
    -> Assignements (AssignExprGenerator)

---- Implementation of Object types ----
  Note: At first, objects won't be freed. I'll use a leak-forever allocator (LinearAllocator).
    GC will come later when the language is officially "feature-complete", because writing a good, reliable
    GC takes time and I'll probably write a better one with the full design of the language implemented.

  -> Common "Object" base
  -> ArrayObject: Always dynamically sized, essentially just a SmallVector (will maybe even inherit from it)
  -> Strings: Similar to ArrayObject. I think they'll also be dynamically sized, but that's subject to change.
 
  Note: In the future, I'll probably have a UserObject and a TupleObject.
        UserObject for structs, TupleObject for tuples.

---- Getting feature-complete (with the current feature set) ----
  -> Codegen of functions
    -> Don't forget to add support of ParamDecl/References to ParamDecl in RegisterAllocator 
       and FuncGenPrologue.
  -> Codegen of global variables
  -> Function calls
  -> Intrinsics/FFI
  -> Basic debug information & trivial exception system (for proper error management).
  -> Test/Document as much as possible.

---- Implementing the GC ----
  (Current ideas, highly subject to changes)
  -> "ReferenceMap" (Safe points) to track register that contain references.
  -> Basic GC algorithm: mark and sweep + colored objects (tri-color). Maybe compacting or generational.
      
Other notes:
  -> InstructionBuilder will be split in multiple builders (BCModuleBuilder, BCFunctionBuilder, etc)
     to be more organized.  