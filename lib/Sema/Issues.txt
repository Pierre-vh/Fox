List of "traps" that semantic analysis might fall into, and that will need to be tested.

	// Will probably fail to determine arraytype
	let x : int[][] = [[],[],[], [1]];
	let x : int[][] = [[],[],[]];

	This exposes a clusterfuck in my logic. I'll have to rest a bit and then rethink the way SemaTypes
	are handled in unifySubtype and tryJoinSemaTypes.

	tryJoinSemaType has literaly no reason to exist. It is unify's job.
	In unify, if we have 2 SemaTypes, I should "unwrap" them both until reaching a Concrete type
	or the last layer of SemaType (->find a name for this). 
	
	This will cover most of my "edge cases" in the unification process.

	About 
		[[], [], [], [1]]

		Everything should solve at the last arg. But currently:
			First loop: 
				proposed = SemaType(nullptr)[]
			Second loop:
				Unification failure

		Expected behaviour
			First loop:
				proposed = SemaType(nullptr)[] // proposed = elemTy;
			Second loop:
				proposed = SemaType(nullptr)[] 
				elemTy = SemaType(proposed) (elemTy->setSubstitution(proposed))
			Third loop:
				proposed = SemaType(nullptr)[]
				elemTy = SemaType(proposed) (elemTy->setSubstitution(proposed))
			Fourth loop:
				proposed unifies with the other arrayType:
					SemaType(Int)[]
			
			Solution application:
				elemTy = proposed's type = ArrayType(SemaType(int))

			Conclusion
				unify should be reworked to worth this way and handle this case gracefully. 
				It should be strictly defined how it unwraps SemaTypes, LValueTypes and ArrayTypes. 
				To elaborate the algorithm, write a dozen of cases that can occur in real world situtation and
				make a "truth table" to help me find a good solution.

				Also, LValues should be strictly controled to not be nested, this should be done
				in "unwrapLValue" in Type

				Unify should also be more used in the Expr analysis. compareSubtypes should never be used directly, always
				through unifySubtype()

				int=float -> true
				int[]=float[] -> true (unwraps arrays)
				@int=int -> true (unwraps args if lvalue)
				SemaType(int)=SemaType(float) -> true (Unwraps if both has sub)
				float=SemaType(nullptr) -> true (2nd sematype becomes SemaType(float))
				SemaType(SemaType(nullptr)) = int -> true (SemaType(SemaType(int)))
				(A)SemaType(nullptr) = (B)SemaType(nullptr) -> true (SemaType A becomes SemaType(B's SemaType))
				ArrayType(SemaType(nullptr)) = ArrayType(int) = Unwraps arrays, calls SemaType(nullptr) = int

				TODO LIST
				Pre-unify checks
					Conditionally unwrap if SemaType has sub until we reach something that isn't a sematype
					or a sematype without sub (Done thru prepareSemaTypeForUnification)

					Unwraps arrays (Done thru performPreUnificationTasks)

					If both SemaType don't have sub, make the first SemaType's sub the 2nd SemaType

					If one is a SemaType and the Other isn't, the SemaType's sub becomes the Other type.