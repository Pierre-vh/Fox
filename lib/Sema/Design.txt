This folder will contain the Semantic Analysis part of the Interpreter.

The semantic analysis' design is pretty trivial, but it has a few tricks up it's sleeve: 
It will essentially mix bidirectional type checking with unidirectional type checking (at least for expression)

The semantic analyzer will mostly work like a traditional unidirectional analyzer, like a C/C++ compiler
would, but in some cases, language constructs in Fox will require contextual information to be resolved.
A simple example is 
	let x : int[] = []
When anylizing the [] node, it's impossible to tell it's type. It could be an array of ints, floats, strings, etc.
So, instead of using hacks, we'll just set it's type to be a ArrayType of a fresh "T0" type. This type will hopefully
be unified later. If it isn't, the second phase of semantic analysis will pick it up and emit an error.

General rule of thumb is:
	Type can be decided with all the elements contained within the node (it's children): assign a definitive type to it
	Type cannot be decided when visiting the node: assign a fresh "t0" type to it.

To unify thoses variables, every node will use a "unification" function. Many kinds of unification will exist, but the
2 most important ones will be:
	* Unification: Traditional unification. 
	* Subtype Unification: This works like traditional unification, but will accept that the LHS and RHS are different concrete
	types, as long as they are of the same family.

This is a bit rough to explain. I guess code will speak for itself, and I'll write more documentation later, when I have the time for it.