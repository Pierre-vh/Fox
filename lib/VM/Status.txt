Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

  Ideas:
    -> Maybe add labels to instructions, so they can be more expressive?
      (e.g. we can have "dest lhs rhs" instead of "arg0 arg1 arg2")
      -> See if it's worth it.

    -> a file with several typedefs (in a "vm" namespace maybe) for:  
        opcode_t (std::uint8_t)
        regnum_t (std::uint8_t)
        instr_int_t (std::uint32_t)
        This will simplify some code in the VM and Instructions.def file

    -> Implement a Sethi-Ullman -like algorithm to decide the evaluation order
       of subexpressions to be a bit more register-efficient.

    -> Potentially add a way of skipping 'useless' expressions on a case-by-case
       basis. 
       e.g. don't compile a 'Unary Not -> Unary Not -> Expr', just compile expr.
       I need to see if there's more of them and if it'd be worthwhile to implement such 
       a feature.

---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators
    -> Declare opcodes (Done)
    -> Implement (Done)
    -> Test (Done)

---- Implementation of control flow ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of casting opcodes ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of basic CodeGen ----
  -> Scaffolding (Done)
  -> InstructionBuilder's buffer can be taken (Done)
  -> Bytecode Dumper (Done)
  -> Registers.hpp
    -> RegisterAllocator (Currently)
    -> RegisterValue (Done)
  -> Basic CodeGen of simple arithmetic expressions : only compile time constant ops involving
      doubles and ints. (Now)
      - Binary Expr : Ints done, Doubles still left to do.
      - CastExpr      (Done)
      - UnaryExpr     (Done)
      -> Write FileCheck tests (Now)

  -> Add a BCGen logRegAlloc option to emit logs about register allocation after
      generating expressions, then, write FileCheck tests checking that the stats
      are correct.

  -> Write more tests, seriously.

  -> Codegen of local variables 
      - LocalVariableUsageCounter walker in BCGenExpr
      - RegAlloc (getRegisterOfVariable, releaseVariable)
      - RegValue (Add a 'variable' kind, releaseVariable on death)

  -> CodeGen of basic statements

---- Implementation of Object types and GC ----
  
  TBA. Will be implemented as Objects, so the GC will be implemented at the same time.
  Objects will be allocated in a special allocator which just uses new/delete, but it'll
  also keep a list of allocated objects. 
  
  -> LinearAllocator.hpp will become Allocator.hpp and share a "MallocAllocator" with it.
     Maybe they'll have a common CRTP base.
  -> Base "Object" class
  -> Array and String objects (derived classes)
  -> "ReferenceMap" to track registers that are/aren't references on the stack
  -> Basic GC algorithm: mark and sweep + colored objects.
      white = unvisited/unmarked, grey = needs to be visited, black = visited
      that deals with cycles fairly easily.

---- The rest ----
  -> Codegen of function & variable declarations
  -> Codegen of global variables
  -> Function calls
  
Note: I'll need a "VMModule" object or something like that. Because, for the VM & CodeGen, I'll need
      to keep track of the number assigned to a function/global, I'll also need a jump table
      to execute functions and globals initializers, etc.
      This will be a tricky part of the design since I need to keep data locality. (all of the 
      bytecode should be allocated in a single large buffer).
      TODO: Find a better name than "VMModule"
      
      Current idea:
        -> InstructionBuilder will be split in multiple builders (Module, Function, GlobalInitializer, etc)
        -> The "Master" Module Builder will keep the table of the globals/functions and will keep the 
           full IR buffer

---- Later/More Advanced ----

  -> Exceptions (only exceptions throwable by the VM, no try/catches for now) 
    -> Relatively trivial for now. This is just to have a proper error handling system
      for division/modulos by zero.

  -> Intrisics/Builtin calls/FFI

  -> Debug info for VM instructions (Optionally generated: accept a "-no-debug-info" switch)
  
