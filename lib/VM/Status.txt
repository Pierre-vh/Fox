Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

Current issues/todos:
  -> Find something other than "AB_INSTR" "ABC_INSTR", etc. 

---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators : >= <= > < == != || &&
    -> Declare opcodes
        // For integers, we only implement == >= and >, the rest can be
        // implemented by adding "nots" or swapping operands as needed, but for
        // doubles every op is implemented because of NaNs stuff
                  ==   !=   <=   <   >=   >     ||     &&
        Integers: ieq      ileq ilt            lnot    or
        Doubles   deq      dleq dlt dgeq dgt
      
    -> Implement
    -> Test

---- Implementation of control flow ----
  -> Declare opcodes
      TBA - I don't know how I'll do it yet since there's many ways to do it.
      Will probably be a "Jump" instruction with a 16 bit signed offset relative to the next
      instruction.

---- Implementation of CodeGen ----
  -> Basic CodeGen of simple expressions : only double and int types.
  -> CodeGen of control flow statements (if/while)
  -> CodeGen entry point (basic decl codegen that just generates the 'main' function's body)

---- Implementation of Object types and GC ----
  
  TBA. Will be implemented as Objects, so the GC will be implemented at the same time.
  Objects will be allocated in a special allocator which just uses new/delete, but it'll
  also keep a list of allocated objects. 
  
  -> LinearAllocator.hpp will become Allocator.hpp and share a "MallocAllocator" with it.
     Maybe they'll have a common CRTP base.
  -> Base "Object" class
  -> Array and String objects (derived classes)
  -> "ReferenceMap" to track registers that are/aren't references on the stack
  -> Basic GC algorithm: mark and sweep + colored objects.
      white = unvisited/unmarked, grey = needs to be visited, black = visited
      that deals with cycles fairly easily.
