Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

  Ideas:
    -> Maybe add labels to instructions, so they can be more expressive?
      (e.g. we can have "dest lhs rhs" instead of "arg0 arg1 arg2")
      -> See if it's worth it.

    -> a file with several typedefs (in a "vm" namespace maybe) for:  
        opcode_t (std::uint8_t)
        regnum_t (std::uint8_t)
        instr_int_t (std::uint32_t)
        This will simplify some code in the VM and Instructions.def file

    -> Implement a Sethi-Ullman -like algorithm to decide the evaluation order
       of subexpressions to be a bit more register-efficient.

    -> Potentially add a way of skipping 'useless' expressions on a case-by-case
       basis. 
       e.g. don't compile a 'Unary Not -> Unary Not -> Expr', just compile expr.
       I need to see if there's more of them and if it'd be worthwhile to implement such 
       a feature.

---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators
    -> Declare opcodes (Done)
    -> Implement (Done)
    -> Test (Done)

---- Implementation of control flow ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of casting opcodes ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of basic CodeGen ----
  -> Scaffolding (Done)
  -> InstructionBuilder's buffer can be taken (Done)
  -> Bytecode Dumper (Done)
  -> Registers.hpp
    -> RegisterAllocator (Currently)
    -> RegisterValue (Done)
  -> Basic CodeGen of simple integral expressions : only compile time constant ops involving
       ints. (Now)
      - Binary Expr : Ints done
      - CastExpr      (Done)
      - UnaryExpr     (Done)
      -> Write FileCheck tests (Done)
      -> Make CodeGen more robust. It should support LValues without a problem. (Done)

  -> VMModule

  -> CodeGen entry points with genFunction, genGlobalVar, etc. None will be functional for now, it'll
     just be an interface.

  -> Add a BCGen logRegAlloc option to emit logs about register allocation after
      generating expressions then write FileCheck tests checking that the stats
      are correct.

  -> Constant Table

  -> Implement the rest of the arithmetic expressions involving Doubles

  -> Codegen of local variables 
      - LocalVariableUsageCounter walker in BCGenExpr
      - RegAlloc (getRegisterOfVariable, releaseVariable)
      - RegValue (Add a 'variable' kind, releaseVariable on death)

  -> CodeGen of Statements


---- Implementation of Object types ----
  Note: At first, objects won't be freed. I'll use a leak-forever allocator (LinearAllocator).
    GC will come later when the language is officially "feature-complete", because writing a good, reliable
    GC takes time and I'll probably write a better one with the full design of the language implemented.

  -> Common "Object" base
  -> ArrayObject: Always dynamically sized, essentially just a SmallVector (will maybe even inherit from it)
  -> Strings: Similar to ArrayObject. I think they'll also be dynamically sized, but that's subject to change.
 
  Note: In the future, I'll probably have a UserObject and a TupleObject.
        UserObject for structs, TupleObject for tuples.

---- Getting feature-complete (with the current feature set) ----
  -> Codegen of functions
  -> Codegen of global variables
  -> Function calls
  -> Intrinsics
  -> Basic debug information & trivial exception system for proper error management.
  -> Test, Test, and Test!

---- Implementing the GC ----
  (Current ideas, highly subject to changes)
  -> "ReferenceMap" (Safe points) to track register that contain references.
  -> Basic GC algorithm: mark and sweep + colored objects (tri-color). Maybe compacting or generational.
      
Other notes:
  -> InstructionBuilder will be split in multiple builders (Module, Function, GlobalInitializer, etc)

