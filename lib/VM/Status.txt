Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

Current issues/todos:
  -> Find something other than "AB_INSTR" "ABC_INSTR", etc. 
  -> Similarly, it'd be great to have a single "Instr" struct that represents
     every instruction possible, using an union or something. This would avoid
     bitwise tricks to retrieve an instruction's data.

---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators : >= <= > < == != || &&
    -> Declare opcodes (Done)
    -> Implement (Done)
    -> Test (Done)

---- Implementation of control flow ----
  -> Declare opcodes
      JumpIf <24 bit signed offset> // Unconditional jump
      CondJump <register> <16 bit signed offset>  // Jump if register != 0
    Note: Offsets are relative to the next instruction.
  -> Implement
  -> Test

---- Implementation of CodeGen ----
  -> Basic CodeGen of simple expressions : only double and int types.
  -> CodeGen of control flow statements (if/while)
  -> CodeGen entry point (basic decl codegen that just generates the 'main' function's body)

---- Implementation of Object types and GC ----
  
  TBA. Will be implemented as Objects, so the GC will be implemented at the same time.
  Objects will be allocated in a special allocator which just uses new/delete, but it'll
  also keep a list of allocated objects. 
  
  -> LinearAllocator.hpp will become Allocator.hpp and share a "MallocAllocator" with it.
     Maybe they'll have a common CRTP base.
  -> Base "Object" class
  -> Array and String objects (derived classes)
  -> "ReferenceMap" to track registers that are/aren't references on the stack
  -> Basic GC algorithm: mark and sweep + colored objects.
      white = unvisited/unmarked, grey = needs to be visited, black = visited
      that deals with cycles fairly easily.
