Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

Current issues/todos:
  -> It'd be great to have a single "Instr" struct that represents
     every instruction possible, using an union or something. This would avoid
     bitwise tricks to retrieve an instruction's data. Unfortunately, it's hard to do
     something nice due to absence of anonymous structs and struct padding in C++.

  -> The macros in "Instructions.def" are not ideal too. It'd be great to clean them up
     so I have less of them and so that they're more flexible.
      -> Current idea: Accept a "is signed" and a "is small" argument
          e.g. BINARY_INSTR(Foo, /*signed*/ true, /*small*/ false)
    
---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators
    -> Declare opcodes (Done)
    -> Implement (Done)
    -> Test (Done)

---- Implementation of control flow ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of basic CodeGen ----
  -> Scaffolding (Done)
  -> InstructionBuilder's buffer can be taken (Done)
  -> Basic CodeGen of simple expressions : only compile time constant ops involving
      doubles and ints.
  -> CodeGen of control flow statements (if/while)

---- Implementation of Object types and GC ----
  
  TBA. Will be implemented as Objects, so the GC will be implemented at the same time.
  Objects will be allocated in a special allocator which just uses new/delete, but it'll
  also keep a list of allocated objects. 
  
  -> LinearAllocator.hpp will become Allocator.hpp and share a "MallocAllocator" with it.
     Maybe they'll have a common CRTP base.
  -> Base "Object" class
  -> Array and String objects (derived classes)
  -> "ReferenceMap" to track registers that are/aren't references on the stack
  -> Basic GC algorithm: mark and sweep + colored objects.
      white = unvisited/unmarked, grey = needs to be visited, black = visited
      that deals with cycles fairly easily.
