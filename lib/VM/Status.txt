Work on this part of the project has just started, so expect the VM to be in
a molten, unfinished state for quite some time. I'll be experimenting a lot!

Basic VM data types and their mappings to Fox types:
    Fox       VM
    int       int
    double    double
    bool      int
    char      int
    string    TBA
    []        TBA
   

Roadmap: Follows a "basic" plan - implement - test development cycle

  Ideas:
    -> Maybe add labels to instructions, so they can be more expressive?
      (e.g. we can have "dest lhs rhs" instead of "arg0 arg1 arg2")
      -> See if it's worth it.

    -> a VMTypes.hpp file with several typedefs (in a "vm" namespace) for:  
        opcode_t (std::uint8_t)
        reg_t (std::uint8_t)
        etc...

---- Initial Preparation and Scaffolding ---- DONE ----

  -> Opcode (Done)
  -> InstructionBuilder (Done)
  -> VM Scaffolding: Registers data structure, basic methods such as run() (Done)

---- Implementation of Int/Double/Bool and related functionalities ----

  -> Implement basic binary operations on integers and doubles: + - * / % (Done)
    -> Declare opcodes (Done)
    -> Implement opcodes (Done)
    -> Do unit tests (Done) -> Add test for mod on negative numbers
       
  -> Implement comparisons & logic operators
    -> Declare opcodes (Done)
    -> Implement (Done)
    -> Test (Done)

---- Implementation of control flow ----
  -> Declare opcodes (Done)
  -> Implement (Done)
  -> Test (Done)

---- Implementation of casting opcodes ----
  -> Declare opcodes
    IntToDouble r1 r2
    DoubleToInt r1 r2 // check if double isn't too large
  -> Implement
  -> Test

---- Implementation of basic CodeGen ----
  -> Scaffolding (Done)
  -> InstructionBuilder's buffer can be taken (Done)
  -> Bytecode Dumper (Done)
  -> Registers.hpp
    -> RegisterAllocator (Currently)
    -> RegisterValue (Done) 
  -> Basic CodeGen of simple expressions : only compile time constant ops involving
      doubles and ints.
  -> CodeGen of control flow statements (if/while)

---- Implementation of Object types and GC ----
  
  TBA. Will be implemented as Objects, so the GC will be implemented at the same time.
  Objects will be allocated in a special allocator which just uses new/delete, but it'll
  also keep a list of allocated objects. 
  
  -> LinearAllocator.hpp will become Allocator.hpp and share a "MallocAllocator" with it.
     Maybe they'll have a common CRTP base.
  -> Base "Object" class
  -> Array and String objects (derived classes)
  -> "ReferenceMap" to track registers that are/aren't references on the stack
  -> Basic GC algorithm: mark and sweep + colored objects.
      white = unvisited/unmarked, grey = needs to be visited, black = visited
      that deals with cycles fairly easily.

---- The rest ----
  -> Globals 
  -> Split the bytecode in functions
  -> Function calls
  
Note: I'll need a "VMModule" object or something like that. Because, for the VM & CodeGen, I'll need
      to keep track of the number assigned to a function/global, I'll also need a jump table
      to execute functions and globals initializers, etc.
      This will be a tricky part of the design since I need to keep data locality. (all of the 
      bytecode should be allocated in a single large buffer).
      
      Current idea:
        -> InstructionBuilder will be split in multiple builders (Module, Function, GlobalInitializer, etc)
        -> The "Master" Module Builder will keep the table of the globals/functions
        -> Once compilation is done, the final "BytecodeBuffer" can be generated by the ModuleBuilder =
          everything copied to a single buffer/vector (using .reserve() + unitialized copies for speed)

---- Later/More Advanced ----

  -> Exceptions (only exceptions throwable by the VM, no try/catches for now) 
    -> Relatively trivial for now. This is just to have a proper error handling system
      for division/modulos by zero.

  -> Intrisics/Builtin calls/FFI

  -> Debug info for VM instructions (Optionally generated, use a "-no-debug-info" switch)
      -> Store a table of pointers to "Debug Info" objects. Theses objects (it's a hierarchy)
        would contain debug info tailored for each situation/case.
  
