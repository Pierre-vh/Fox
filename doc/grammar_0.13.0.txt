Fox Grammar version 0.13.1

// Note : { } means "0 or more", [ ] means "optional"

##Base rule (The parsing process starts from this rule.)
<fox_unit>	= {<declaration>}1+	// Note, in the future I'll add the <import> too, but not yet. I'll implement them later.

##General Rules##
<id> 				= Any non-reserved keyword that is recognized by the following regular expression : (([A-Z]|[a-z]|_)([A-Z]|[0-9]|[a-z]|_)?)+ that contains at least one character.

##Types##
<builtin_type_name> = "int" 	| "float"		| "bool"	| "string"		| "char"
<type>		= <builtin_type_name> { '[' ']' }
<qualtype>	= ':' ["const"] ['&'] <type> // A Fully Qualified Type

##Exprs##
<primitive_literal>	= One literal of the following type : Integer, Floating-point, Boolean, String, Char
<expr_list>		= <expr> {',' <expr> }
<parens_expr_list>	= '(' [ <expr_list> ] ')'
<expr_stmt>		= ';' | <expr> ';' 
<parens_expr>	= '(' <expr> ')'

<suffix>		= '.' <id> | '[' <expr> ']' | <parens_expr_list>
<array_literal>	= '[' [<expr_list>] ']'
<literal>		= <primitive_literal> | <array_literal>
<declref>		= <id>
<primary>		= <literal> | <parens_expr> | <declref>
<suffix_expr>	= <primary> { <suffix> }
<exp_expr>		= <suffix_expr> [ <exponent_operator> <prefix_expr> ]
<prefix_expr>   = <unary_operator> <prefix_expr> | <exp_expr>
<cast_expr>     = <prefix_expr> ["as" <type>]
<binary_expr>   = <cast_expr> { <binary_operator> <cast_expr> }	// note about this rule: use precedence-climbing to manage priority of operation ! (see ParseExpr.cpp, line 237+ to see how it's handled)
<expr>          = <binary_expr> [<assign_operator> <expr>] 

<exponent_operator> = '*' '*'
<assign_operator> = '='
<binary_operator> =  '+' | '-' | '*' | '/' | '%' | ('&' '&') | ('|' '|') | ('<' | '>' | ('=' '=') | ('>' '=') | ('<' '=') | ('!' '=') 
<unary_operator>  =  '!' | '-' | '+'

/*
	OPERATION PRIORITY FROM HIGHEST TO LOWEST
		Member access ".", Array Access "[]", Function call "()"
		**
		unary - ! +
		cast "as"
		* / % 
		+ -
		< > <= >= 
		== !=
		&&
		||
		= 
*/

##Decls##
<declaration> = <func_decl> | <var_decl>
<func_decl>	= "func" <id> '(' [<arg_decl> {',' <arg_decl>}] ')'[':' <type>] <compound_statement>
<arg_decl>	= <id> <qualtype>
<expr_list>	= '(' [<expr> {',' <expr>}] ')'
<rtr_stmt>	= "return" [<expr>] ';'

##Decl-Stmt##
<import>        = ("import" | "using") <id> {'.' (<id> | '*')} ';'
<var_decl>		= "let" <id> <qualtype> ['=' <expr>] ';' 

##Stmts##
<compound_statement> = '{' {<stmt>} '}'
<condition>		= "if"		<parens_expr> <body> ["else" <body>]
<while_loop> 	= "while"	<parens_expr> <body>
<body>			= <stmt> | <compound_statement>
<stmt>			= <var_decl> | <expr_stmt> | <condition> | <while_loop> | <rtr_stmt> 