Fox Grammar version 0.15.2

// Note : { } means "0 or more", [ ] means "optional"

## Lexical Structure
<id> = Any non-reserved keyword that is recognized by the following regular expression : (([A-Z]|[a-z]|_)([A-Z]|[0-9]|[a-z]|_)?)+ that contains at least one character.

## Types
<builtin_type_name> = "int" | "float" | "bool" | "string" | "char"
<type> = ('[' <type> ']') | <builtin_type_name>

## Expressions
<primitive_literal> = One literal of the following type : Integer, Floating-point, Boolean, String, Char
<expr_list> = <expr> {',' <expr> }
<parens_expr_list> = '(' [ <expr_list> ] ')'
<expr_stmt> = <expr> ';' 
<parens_expr> = '(' <expr> ')'
<suffix> = '.' <id> | '[' <expr> ']' | <parens_expr_list>
<array_literal>  = '[' [<expr_list>] ']'
<literal> = <primitive_literal> | <array_literal>
<declref> = <id>
<primary> = <literal> | <parens_expr> | <declref>
<suffix_expr> = <primary> { <suffix> }
<exp_expr> = <suffix_expr> [ <exponent_operator> <prefix_expr> ]
<prefix_expr> = <unary_operator> <prefix_expr> | <exp_expr>
<cast_expr> = <prefix_expr> ["as" <type>]
<binary_expr> = <cast_expr> { <binary_operator> <cast_expr> }  // note about this rule: use precedence-climbing to manage priority of operation ! (see ParseExpr.cpp, line 237+ to see how it's handled)
<expr> = <binary_expr> [<assign_operator> <expr>] 

<exponent_operator> = '*' '*'
<assign_operator> = '='
<binary_operator> =  '+' | '-' | '*' | '/' | '%' | ('&' '&') | ('|' '|') 
                         | ('<' | '>' | ('=' '=') | ('>' '=') | ('<' '=') | ('!' '=') 
<unary_operator>  =  '!' | '-' | '+'

/*
  Operation precedence, in descending order. 
    Member access ".", Array Access "[]", Function call "()"
    **
    unary - ! +
    cast "as"
    * / % 
    + -
    < > <= >= 
    == !=
    &&
    ||
    = 
*/

## Declarations
<fox_unit> = {<declaration>}1+
<declaration> = <func_decl> | <var_decl>
<func_decl> = "func" <id> '(' [<param_decl> {',' <param_decl>}] ')'[':' <type>] <compound_stmt>
<param_decl> = <id> ':' ["mut"] <type> // Parameters are immutable by default.
<expr_list> = '(' [<expr> {',' <expr>}] ')'
<var_decl> = ("let" | "var") <id> ':' <type> ['=' <expr>] ';' // let is a constant variable

## Statements
<compound_stmt> = '{' {<stmt>} '}'
<condition> = "if" <expr> <compound_stmt> ["else" (<compound_stmt> | <condition>)]
<while_loop> = "while" <expr> <compound_stmt>
<stmt> = <var_decl> | <expr_stmt> | <condition> | <while_loop> | <rtr_stmt> 
<rtr_stmt> = "return" [<expr>] ';'