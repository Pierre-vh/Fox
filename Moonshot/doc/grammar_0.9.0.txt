Fox Grammar version 0.9.0

Modifications used in this grammar :
$x means x is a term already recognized and identified by the lexer. 
	$id means a lexer-recognized id 
	$const means a constant value, recognized by the lexer. Examples : 'c' "foo" 3.14 -1 true (raw, hard coded constants)

Note about the typing discipline :
It tends to be strongly typed, because a variable can't be converted to another type.(if you declared an int, you can't transform it in a string. If you attempt to store a string in a int,
you'll be greeted with an error!)

##Base rule (The parsing process starts from this rule.)
<fox_file>	= {(<func_decl> | <var_decl>)}+			// At least 1 function/variable declaration.

##General Rules##

<id> 				= $id
<type> 				= "int 	| "float" | "bool" | "string" | "char"
<literal>			= $int_val 	| $float_val | $bool_val | $string_val 	| $char_val

<type_spec>			= ':' ["const"] <type>				
<compound_statement>= '{' {<stmt>} '}'		// Statements delimited by curly brackets.

<import>        = ("import" | "using") <id> {'.' (<id> | '*')} ';' // Note: Stop (break loop) if '*' is found

<stmt>			= <var_decl> | <expr_stmt> | <condition> | <while_loop> | <rtr_stmt> 
<body>			= <stmt> | <compound_statement>

<expr_stmt>		= ';' | <expr> ';' 
<parens_expr>	= '(' <expr> ')'

<value>         = <parens_expr> | <id> | <literal>
<trailer>       = '.' <id> '(' <expr_list> ')'
<atom>          = <value> { <trailer> }
<exp_expr>      = <atom> [ <exponent_operator> <prefix_exp> ]
<prefix_expr>   = <unary_operator> <prefix_expr> | <exp_expr>
<cast_expr>     = <prefix_expr> ["as" <type]
<binary_expr>   = <cast_expr> { <binary_operator> <cast_expr> }	
<expr>          = <binary_expr> [<assign_operator> <expr>] 

<exponent_operator> = '*' '*'
<assign_operator> = '='
<binary_operator> =  '+' | '-' | '*' | '/' | '%' | ('&' '&') | ('|' '|') | ('<' | '>' | ('=' '=') | ('>' '=') | ('<' '=') | ('!' '=') 
<unary_operator>  =  '!' | '-' | '+'  // inversion, -,+ (+ is essentially a non op for now, it's syntaxic sugar)

/*
	Final operation priority
	**
	unary - ! +
	cast "as"
	* / % 
	+ -
	< > <= >= 
	== !=
	&&
	||
	=
*/

##Variables##
<var_decl>		= "let" <id> <type_spec> ['=' <expr>] ';' 	// You can define variables in a rust-like fashion, but you can specify the type of the variable. const variables can't be modified.

##Functions##
<func_decl>		= "func" <id> '(' [<arg_decl_list>] ')'[':' <type>] <compound_statement>	// Note about type_spec : if it is not present, the function returns void.
<arg_decl_list> = [<arg_decl> {',' <arg_decl>}*]
<arg_decl>		= <id> : ["const"]['&'] <type>
<expr_list>		= '(' [<expr> {',' <expr>}] ')'
<rtr_stmt>		= "return" [<expr>] ';'

##Control Flow##
<condition>			= "if"		<parens_expr> <body> ["else" <body>]
<while_loop> 		= "while"	<parens_expr> <body>

##PENDING##
// New grammar version after this change: 0.9.5 
// Changelong: 
//	added <expr_list> rule (it was referenced in other rules, but not defined anywhere!)
//	reworked <expr> grammar
//		added <qualified_id> to represent namespaces
//		added <decl_ref> to support both "primary" function and variable calls.
//		<value> renamed to <primary>, removed <id> and added <decl_ref> instead
//		deleted <atom> and <trailer> rule
//	Added a optional <member_access> rule. Not need for now because I don't have oop, but will be useful later.

// I'm going to test theses changes before implementing them. 

<qualified_id>			= <id> { '.' <id }
<expr_list>				= <expr> {',' <expr> }
<decl_ref>				= <qualified_id> [ '(' <expr_list> ')' ] 
// <member_access>	= <primary> { '.' <id> [ '(' <expr_list> ')' ] } // this part is for OOP (chaining, member access, etc). Won't be in for now.
<primary>		= <literal> | <parens_expr> | <decl_ref>
<exp_expr>      = <primary> [ <exponent_operator> <prefix_exp> ]

