Fox Grammar version 1.4.1
// Changelog:
1.2 : Cleanup of the grammar.
// 18/12/2017
1.3 : Now using Expression Statements instead of f_call_stmt and var_ass_stmt.
	> Added <expr_stmt> which replaces var_assign & f_call statements.
1.4 : For simplicity's sake, i removed the namespace idea for now.
	After some thinking, I realised that it will be a lot harder than I first thought to implement.
	The feature is still planned, but not for now !
	Same for includes, they're useless now, really.
1.4.1 : <block> renamed to <compound_statement> for readability's sake. Using custom names has no benefits and is a bad habit i'm trying to ditch.
1.4.2 : <return> : <expr> is now optional (to allow "return;" in void functions)
1.4.3 :	Deleted the <ctrl_flow> non-terminal and added | <condition> | <while_loop> to <stmt> rule.
1.5	: Expression rework. They're now far more flexible and support unary operation chaining, like !!false, !-3, etc.
1.5.1 : Changed Exponent sign to "**" instead of '^' like in other languages ( python, fortran,.. )


Modifications used in this grammar :
$x means x is a term already recognized and identified by the lexer. 
	$id means a lexer-recognized id 
	$const means a constant value, recognized by the lexer. Examples : 'c' "foo" 3.14 -1 true (raw, hard coded constants)

Note about the typing discipline :
It tends to be strongly typed, because a variable can't be converted to another type.(if you declared an int, you can't transform it in a string. If you attempt to store a string in a int,
you'll be greeted with an error!)

##Base rule (The parsing process starts from this rule.)
<fox_program>	= {(<func_decl> | <var_decl>)}+			// At least 1 function/variable declaration.

##General Rules##

<id> 			= $id
<type> 			= $int_kw 	| $float_kw 	| $bool_kw	| $string_kw 	| $char_kw | $void_kw
<const>			= $int_val 	| $float_val 	| $bool_val 	| $string_val 	| $char_val

<namespace> 		= {<id> '.'} 						// This designates namespaces, examples : "Fox." "Fox.io."
														// You can also import packages that don't have sub packages (or import everything in the package at the same time !). "Fox" works here
<type_spec>		= ':' [$const_kw] <type>				// Used later..
<arg_type_spec>		= ':' ['&'] <type>					// the optional ampersand indicates pass by reference
<eoi>			= ';'									// End of instruction character. I use a separate rule for this, in case i want to modify it someday. (to use \n for instance)
<compound_statement>			= '{' {<stmt>} '}'		// Statements delimited by curly brackets.
				= <stmt>								// A compound_statement can also be just one statement.
<stmt>			= <var_decl> | <expr_stmt> | <condition> | <while_loop>

<expr_stmt>		= <expr> <eoi>

<value>         = <callable> | <const> | '(' <expr> ')'
<prefix_expr>   = <unary_operator> <prefix_expr> | <value>
<cast_expr>     = <prefix_expr> [<as_kw> <type>] 
<expr> 			= <cast_expr> { <binary_operator> <cast_expr> }	

<callable>		= <id>
				= <f_call>

<binary_operator> =  '=' | '+' | '-' | ('*' '*') | '*' | '/' | '%' | ('&' '&') | ('|' '|') | ('<' | '>' | ('=' '=') | ('>' '=') | ('<' '=') | ('!' '=') 
<unary_operator>  =  '!' | '-'  // inversion, negative

/*
	// Operator priority, in decreasing order :
		0. **				-> right associative
		1. * / % 
		2. + -
		3. < > <= >= 
		4. == !=
		5. &&
		6. ||
		7. =				-> right associative
*/



##Variables##

<var_decl>		= <let_kw> <id> <type_spec> ['=' <expr>] <eoi> 	// You can define variables in a rust-like fashion, but you can specify the type of the variable. const variables can't be modified.

##Functions##

<func_decl>		= <fn_kw> <id> <arg_list_decl> [<type_spec>] <compound_statement>	// Note about type_spec : if it is not present, the function is considered void (it will never return anything and return values will be discarded.)
<arg_list_decl> 	= '(' [<arg_decl> {',' <arg_decl>}*] ')'
<arg_decl>		=  <id> <arg_type_spec> 				// argument are (by default) passed by value, the ampersand indicates passing by reference.

<f_call>		= <id> <expr_list>						// Function calls used in expressions, etc..
<expr_list>		= '(' [<expr> {',' <expr>}] ')'

<rtr_stmt>		= <rtr_kw> [<expr>] <eoi>

##Control Flow##
<condition>		= <if_kw> {<elif_kw>}* [<else_branch>]?		
<if_branch>		= <if_kw> '(' <expr> ')'			<compound_statement>
<elif_branch> 	= <el_kw> <if_kw> '(' <expr> ')' 	<compound_statement>
<else_branch>	= <el_kw>							<compound_statement>
<while_loop> 	= <wh_kw>  '(' <expr> ')'			<compound_statement> 

##SCRAPPED IDEA : MIGHT RETURN LATER##
	<ext_id>		= [<namespace>] <id>						// External IDs, examples : "Fox.foo"	"Fox.io.print"
	<general_id>		= <ext_id> | <id>
	##Importing Packages##
	<import_stmt>   = ( <imp_kw> | <use_kw> ) <ext_id> <eio>