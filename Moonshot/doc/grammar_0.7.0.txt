Fox Grammar version 0.7.0
// Changelog:
0.2 : Grammar cleanup
0.3 : Now using Expression Statements instead of f_call_stmt and var_ass_stmt.
	> Added <expr_stmt> which replaces var_assign & f_call statements.
0.4 : For simplicity's sake, i removed the namespace idea for now.
	After some thinking, I realised that it will be a lot harder than I first thought to implement.
	The feature is still planned, but not for now !
	Same for includes, they're useless now, really.
0.4.1 : <block> renamed to <compound_statement> for readability's sake. Using custom names has no benefits and is a bad habit i'm trying to ditch.
0.4.2 : <return> : <expr> is now optional (to allow "return;" in void functions)
0.4.3 :	Deleted the <ctrl_flow> non-terminal and added | <condition> | <while_loop> to <stmt> rule.
0.5	: Expression rework. They're now far more flexible and support unary operation chaining, like !!false, !-3, etc.
0.5.1 : Changed Exponent sign to "**" instead of '^' like in other languages ( python, fortran,.. )
0.6	:	Final pass on the expressions : right associativity is directly specified in the grammar for exponent and = operators. 
		Changed exponent operator's priority to be mathematically correct.
		Renamed <const> to <literal>*
		Added '+' unary op
0.6.5 : Changed <compound_statement> rule : removed <statement> as an option
		Changed statement rule: added the <compound_statement> and <rtr_stmt> rule as options
		Changed <compound_statement> in statements that used it before to just <statement>
0.7.0 :	Removed the <eoi> nonterminal. It was completly useless. I just replaced all of them with ';'
		Changed (and corrected) the grammar for if/else if/else statements. It had a typo, and i've cleaned it up a bit to eliminate redudancy.
		Added the empty ';' statement to the expression statement, like in C and C++.
		Removed the namespace rule and added it to the scrapped idea part. It was already scrapped for now, I've just made it clear.
		Removed the <xxx_kw> nonterminal, as it was useless. I replaced every <XXX_kw> rule by the proper keyword (e.g. <wh_kw> -> "while")
Modifications used in this grammar :
$x means x is a term already recognized and identified by the lexer. 
	$id means a lexer-recognized id 
	$const means a constant value, recognized by the lexer. Examples : 'c' "foo" 3.14 -1 true (raw, hard coded constants)

Note about the typing discipline :
It tends to be strongly typed, because a variable can't be converted to another type.(if you declared an int, you can't transform it in a string. If you attempt to store a string in a int,
you'll be greeted with an error!)

##Base rule (The parsing process starts from this rule.)
<fox_file>	= {(<func_decl> | <var_decl>)}+			// At least 1 function/variable declaration.

##General Rules##

<id> 				= $id
<type> 				= "int 	| "float" | "bool" | "string" | "char"
<literal>			= $int_val 	| $float_val 	| $bool_val | $string_val 	| $char_val

<type_spec>			= ':' ["const"] <type>				
<arg_type_spec>		= ':' ['&'] <type>					// the optional ampersand indicates pass by reference
<compound_statement>= '{' {<stmt>} '}'		// Statements delimited by curly brackets.

<stmt>			= <var_decl> | <expr_stmt> | <condition> | <while_loop> | <compound_statement> | <rtr_stmt> 

<expr_stmt>		= ';' | <expr> ';' 

<value>         = <callable> | <literal> | '(' <expr> ')' 
<exp_expr>      = <value> [ <exponent_operator> <prefix_exp> ]
<prefix_expr>   = <unary_operator> <prefix_expr> | <exp_expr>
<cast_expr>     = <prefix_expr> ["as" <type]
<binary_expr>   = <cast_expr> { <binary_operator> <cast_expr> }	
<expr>          = <binary_expr> [<assign_operator> <expr>] 

<callable>		= <id>
				= <f_call>

<exponent_operator> = '*' '*'
<assign_operator> = '='
<binary_operator> =  '+' | '-' | '*' | '/' | '%' | ('&' '&') | ('|' '|') | ('<' | '>' | ('=' '=') | ('>' '=') | ('<' '=') | ('!' '=') 
<unary_operator>  =  '!' | '-' | '+'  // inversion, -,+ (+ is essentially a non op for now, it's syntaxic sugar)

/*
	Final operation priority
	**
	unary - ! +
	cast "as"
	* / % 
	+ -
	< > <= >= 
	== !=
	&&
	||
	=
*/



##Variables##
<var_decl>		= "let" <id> <type_spec> ['=' <expr>] ';' 	// You can define variables in a rust-like fashion, but you can specify the type of the variable. const variables can't be modified.

##Functions##
<func_decl>		= "func" <id> <arg_list_decl> [<type_spec>] <compound_statement>	// Note about type_spec : if it is not present, the function returns void.
<arg_list_decl> = '(' [<arg_decl> {',' <arg_decl>}*] ')'
<arg_decl>		=  <id> <arg_type_spec> 				// argument are (by default) passed by value, the ampersand indicates passing by reference.
<f_call>		=  <id> <expr_list>						// Function calls used in expressions, etc..
<expr_list>		= '(' [<expr> {',' <expr>}] ')'
<rtr_stmt>		= "return" [<expr>] ';'

##Control Flow##
<condition>			= <cond_if> {<cond_elseIf>} [<cond_else>]
<cond_if>			= "if				'(' <expr> ')'	<statement>
<cond_elseIf>		= "else" "if"		'(' <expr> ')'	<statement> 
<cond_else>			= "else"							<statement>
<while_loop> 		= "while"			'(' <expr> ')'	<statement> 

##SCRAPPED IDEA : MIGHT RETURN LATER##
	<namespace> 		= {<id> '.'} 						// This designates namespaces, examples : "Fox." "Fox.io."
	// all of that package system will return at some point later, I just want to get the backend up and running before implementing multiple file support
	<ext_id>		= [<namespace>] <id>						// External IDs, examples : "Fox.foo"	"Fox.io.print"
	<general_id>	= <ext_id> | <id>
	##Importing Packages##
	<import_stmt>   = ( "import" | "using" ) <ext_id> ';'