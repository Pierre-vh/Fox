Feature name:
	Expression Functions

Motivation:
	Bring a way of interacting with data in an easy and comprehensible way.

Grammar:
	I needs to support expressions on literals, callables and complete expressions, be of the highest precedence.
	AND it needs to support chaining.

	This should work:
	<values> {'.' <id> <expr_list>} (0+)

	One advantage of this rule, with minor adjustements in the typechecks (check if the type of value is a primitive)
	it totally support calling objects!
	foo.bar(); would be parsed as 

		EXPR_FUNC
  FOO (expr)	BAR (the function's name)

Where it would fit in the current grammar:
	<value>         = <callable> | <literal> | '(' <expr> ')' 
	<expr_func>		= <value> {'.' <id> <expr_list> }
	<exp_expr>      = <expr_func> [ <exponent_operator> <prefix_exp> ]
	<prefix_expr>   = <unary_operator> <prefix_expr> | <exp_expr>
	<cast_expr>     = <prefix_expr> [<as_kw> <type]
	<binary_expr>   = <cast_expr> { <binary_operator> <cast_expr> }	
	<expr>          = <binary_expr> [assign_operator> <expr>] 
	
	

Example of use
	"Foo bar".substr(0,3).toChar(0); // Does a substring on "Foo bar", returning "Foo", then converts the first char (index 0) to a char.


Issues :
	I doubt it's going to be that easy, there must be a problem somewhere!
	Find a better name than expression function
	Maybe use '->' instead of '.' to avoid issues with floats, so this would be parsed without any issue : 0.2->asString();

Further development:
	Add the possibility for the user to create expression functions, with a syntax like this for instance
	Eventually, all expression functions from the standard library should be moved and use that system.

	[data:int] toFloat(): float{
		return data as float;
	}