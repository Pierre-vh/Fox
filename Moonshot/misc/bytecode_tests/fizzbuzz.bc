	declfunc 0					// 0 is the function index in the globals table
		.meta	"fizzbuzz"		// .meta tag for the function : "fizzbuzz"
		decllocal	0		
			.meta	"count" 
		loadloc	0 // while part
		const	100
		cmp_leq		// TOS2 less or equal (<=) TOS1
		cond_jump	56 // Jump
		beginscope
			loadloc 0 // while body: first if
			const 3
			mod
			const	0
			cmp_eq
			cond_jump 4	// goes to 13+2 = 15 if false
			beginscope
				loadext 0	// load external function 0 (print)
				const "fizz"
				callf 1	// calls a function with 1 arg. 1 arg is pop'd + the func ref (loadext)
			endscope
			loadloc 0 // while body : second if
			const 3
			mod
			const 0
			cmp_eq
			cond_jump 4
			beginscope
				loadext 0
				const "buzz"
				callf 1
			endscope
			loadloc 0 // while body :third if
			const 3
			mod
			const 0	
			cmp_eq
			loadloc 0
			const 5
			mod
			const 0
			cmp_eq
			and
			cond_jump 4
			beginscope
				loadext 0
				const "fizzbuzz"
				callf 1
			endscope
			loadloc 0 // increment
			const 1
			add
			storeloc 0
			goto 6 // end of loop
		endscope
		return	// return from function, pop frame, add return value to main stack (here, none, so nothing is added)

This example is raw, without any optimization.
A simple one at the AST level would be to check if there are variable declarations
in a compound statement. If yes, generate the beginscope/endscope, if not, don't generate it.

The algo for generating Conditions and Loops is :
	if compound statement contains declarations
		emit("beginscope");
		compoundstatement->generateCode
		emit("endscope");
	else
		compoundstatement->generateCode

This could be automated at the compoundstatement->generateCode level, but the method should take "mode" argument
so it knows how to behave if the caller is a function.

Design goals for the codegen visitor :
	-> The visit method should have a way of knowing what is the parent object. a IASTNode (constant?) reference should suffice.
	-> constexpressions should be evaluated directly.
