This is a rough idea of how the interpreter will work. I'm writing this down to see potential flaws and obstacles. Feel free to comment, if anyones ever reads this!

1 - Parsing Driver : It is fed a Base directory, and a list of all file contained in the subdirectories that are part of the build process.
e.g. "C:/User/Pierre/Fox/Proj1/" as base directory, and "com/personal/main.fox", "com/personal/fib.fox" as files.
It generates a database of each file in a "Master" node, with the package name as key, and the parsed AST of the file as data.
Example of said database:
	"com.personal.main" -> main.fox's ast
	"com.personal.fib" -> fib.fox's  ast
To do so, it calls the parser and lexer on each file:
	a - Lexer : Divides each file's content into tokens.
	b - Parser : Takes the token vector of each file and parse them to produce an AST.

2a - Scope Checker : Create a "Scoped Symbols Table". The representation of this is still to be decided.I think I'll just use a tree, with a symbols table (std::map) in each node, but the proper way of linking it to
each node is still to be decided. The general idea would be to add to each node where scope matters : function, control flow, compound statements,
a pointer to the corresponding node in the symbols table tree. The symbols table tree should have function on each node
to search for a given variable name in the current node and all parents.
The scoped symbols table must have a special node for file-level scopes that has pointers to other file's symbols table depending on the imports.

2b - Type Checker : 
	* For every function and variable declaration, it adds the information about the type in the SST.
	* For every expression, it checks if the expression is legal.
	* For every statement that uses an expression (control flow, function calls) 
	  it checks if the given expression returns a correct type that is strictly the same 
	  or can be implicitely casted without losing information.

2c - Other optional semantics check, but the syntax is fairly simple for now, so there's no need for that currently.

At this point, we have a complete AST with it's typed, scoped symbols table. The first part of the compilation process is done!

3a - Main IR Generation
	 The IR will be a Three Adress code. The AST will be discarded and not used further, it will be replaced by a structure holding the IR.
	 The structure will have a root node that'll roughly act the same as the AST's root node (managing files and packages names) except it's data in the map will be a structure, let's call it "FileLevelIR" for now.
	 This "FileLevelIR" class will hold the IR for the class's "Header" (global variable declarations) and the IR of each function.
	 NOTE: I'll try to keep the IR close to the Bytecode as much as possible to minimize transformations later. 
	 NOTE: I might seek help for this part, I don't know what's the best way to store the global variable's declaration.

3b - Basic blocks definition : Each function's IR array is divided in Basic blocks. This step is somewhat important if I want to generate a CFG later to optimize the code further.
	 This also let me exploit some properties of a basic block in optimizations.

4 - Optimization Pass : Constant folding and propagation. They're both run in a loop until they can't find anything to optimize anymore within a basic block.
	4a : Constant folding : Each time the Constant Folding Optimization Function finds a TAC instruction
		 with 2 constants and a mathematical operation, it evaluates and replaces it with an assignement to the result. 
		 e.g. :
			this:
				t1 = 3 + 3
			becomes:
				t1 = 6
	4b : Constant propagation : Within a basic block, each occurence of a temporary variable that is a constant is replaced by the constant, and it's assignement is deleted.
		 (This will be improved later if a CFG is added to propagate the new value further.)
		e.g. :
			this: 
				t1 = 6
				t2 = t1+1
			becomes:
				t2 = 6+1
  
5 - Other optimizations might be performed later, but theses 2 are the most basic and they'll be the only one done at first.
6 - Bytecode Generation : The IR is transformed into stack based bytecode. This is done for each file. In the end, only a structure holding the packages & files and their corresponding Bytecode is left.
	See : https://www.reddit.com/r/ProgrammingLanguages/comments/7zwsv7/generating_stackbased_bytecode_like_the_jvms_from/ for how to do it properly.