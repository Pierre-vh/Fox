//----------------------------------------------------------------------------//
// This file is part of the Fox project.        
// See the LICENSE.txt file at the root of the project for license information.            
// File : Instructions.def                      
// Author : Pierre van Houtryve                
//----------------------------------------------------------------------------//
// This file uses Macro to "register" every Opcode supported by the Fox VM.
//----------------------------------------------------------------------------//
/*
  Instructions are fixed width and are 32 bits wide. They are pretty similar
  to LuaJIT's instructions. The Opcode always occupies the first 8 bits
  of the instruction. The rest of the instruction can then be split in 2 ways
  depending on the opcode:
      - Divided in 3 8 bits chunk (A B C)
      - Divided in 1 8 bits chunk and another 16 bits chunk.  (A D)

  32    24   16     8      0
  |  C  |  B  |  A  |  OP  |
  |     D     |  A  |  OP  |

  Some instructions may not use any operand at all. Such operations
  are called "Simple" operations.

  TL;DR: 4 instruction kind (for now) (they all have the opcode as first byte)
    - Simple: No args
    - Ternary: 3 args: 1 byte (a) + 1 byte (b) + 1 byte (c)
    - Binary: 2 args: 1 byte (a) + 2 byte (d)
    - Small Binary: 2 args: 1 byte (a) + 1 byte (b)
*/
//----------------------------------------------------------------------------//

// Any instruction
#ifndef INSTR
  #define INSTR(ID)
#endif

#ifndef LAST_INSTR
  #define LAST_INSTR(ID)
#endif

// Simple instruction with no arguments.
// Default behaviour is to do the same as INSTR
#ifndef SIMPLE_INSTR
  #define SIMPLE_INSTR(ID) INSTR(ID)
#endif

// Ternary instruction with three 8 bits arguments: a, b and c.
// Default behaviour is to do the same as INSTR
#ifndef TERNARY_INSTR
  #define TERNARY_INSTR(ID) INSTR(ID)
#endif

// Binary instructions with one 8 bit + one 16 bit arguments: a and d.
// Default behaviour is to do the same as INSTR
#ifndef BINARY_INSTR
  #define BINARY_INSTR(ID) INSTR(ID)
#endif

// Binary instructions with two 8 bit arguments: a and b.
// Default behaviour is to do the same as BINARY_INSTR
#ifndef SMALL_BINARY_INSTR    
  #define SMALL_BINARY_INSTR(ID) BINARY_INSTR(ID)
#endif


//----------------------------------------------------------------------------//

SIMPLE_INSTR(NoOp)
SIMPLE_INSTR(Break)

// Loads the value of D (interpreted as a signed int16) in register A
BINARY_INSTR(StoreSmallInt) // Can this work with signed ints too?

// Arithmetic : a = b (op) c. Result's type is the type of the operand.
TERNARY_INSTR(AddInt)     // Int Addition
TERNARY_INSTR(AddDouble)  // Double Addition
TERNARY_INSTR(SubInt)     // Int Substraction
TERNARY_INSTR(SubDouble)  // Double Substraction
TERNARY_INSTR(MulInt)     // Int Multiplication
TERNARY_INSTR(MulDouble)  // Double Multiplication
TERNARY_INSTR(DivInt)     // Int Division
TERNARY_INSTR(DivDouble)  // Double Division
TERNARY_INSTR(ModInt)     // Int Modulo
TERNARY_INSTR(ModDouble)  // Double Modulo
TERNARY_INSTR(PowInt)     // Int exponentiation
TERNARY_INSTR(PowDouble)  // Double exponentiation

// Comparisons a = b (cond) c. Result is always an int (1 for true, 0 for false)
TERNARY_INSTR(EqInt)      // Int Equality
TERNARY_INSTR(LEInt)      // Int Less or Equal
TERNARY_INSTR(LTInt)      // Int Less Than
TERNARY_INSTR(EqDouble)   // Double Equality
TERNARY_INSTR(LEDouble)   // Double Less or Equal
TERNARY_INSTR(LTDouble)   // Double Less Than
TERNARY_INSTR(GEDouble)   // Double Greater or Equal
TERNARY_INSTR(GTDouble)   // Double Greater Than

// Other arithmetic/logic ops that operate on raw values
SMALL_BINARY_INSTR(LNot)  // Logical NOT
TERNARY_INSTR(LOr)        // Logical OR
TERNARY_INSTR(LAnd)       // Logical AND

LAST_INSTR(LAnd)

//----------------------------------------------------------------------------//

#undef INSTR
#undef SIMPLE_INSTR
#undef TERNARY_INSTR
#undef BINARY_INSTR
#undef SMALL_BINARY_INSTR
#undef LAST_INSTR