//----------------------------------------------------------------------------//
// This file is part of the Fox project.        
// See the LICENSE.txt file at the root of the project for license information.            
// File : Instructions.def                      
// Author : Pierre van Houtryve                
//----------------------------------------------------------------------------//
// This file uses Macro to "register" every Opcode supported by the Fox VM.
//----------------------------------------------------------------------------//
/*
  Instructions are fixed width and are 32 bits wide. They are pretty similar
  to LuaJIT's instructions. The Opcode always occupies the first 8 bits
  of the instruction. The rest of the instruction can then be split in 2 ways
  depending on the opcode:
      - Divided in 3 8 bits chunk (A B C)
      - Divided in 1 8 bits chunk and another 16 bits chunk.  (A D)

  32    24   16     8      0
  |  C  |  B  |  A  |  OP  |
  |     D     |  A  |  OP  |

  Some instructions may not use any operand at all. Such operations
  are called "Simple" operations.

  TL;DR: 4 instruction kind (for now)
    - Simple: Just the opcode, no args.
    - AB: Opcode + 2 Byte-sized operands (2 x 8 bits). Last 8 bits unused.
    - ABC: Opcode + 3 Byte-sized operands (3 x 8 bits)
    - AD: Opcode + 1 Byte-sized operand and another 2 bytes operand 
          (1 x 8 bits + 1 x 16 bits)

   An important thing to consider is that ops may not use all of their arguments.
   Check the doc of the opcode (if I wrote it by the time you're reading this) to
   know which operands are used.
*/
//----------------------------------------------------------------------------//

#ifndef INSTR
  #define INSTR(ID)
#endif

#ifndef LAST_INSTR
  #define LAST_INSTR(ID)
#endif

#ifndef SIMPLE_INSTR
  #define SIMPLE_INSTR(ID) INSTR(ID)
#endif

#ifndef ABC_INSTR
  #define ABC_INSTR(ID) INSTR(ID)
#endif

#ifndef AB_INSTR
  #define AB_INSTR(ID) INSTR(ID)
#endif

#ifndef AD_INSTR
  #define AD_INSTR(ID) INSTR(ID)
#endif

//----------------------------------------------------------------------------//

SIMPLE_INSTR(NoOp)
SIMPLE_INSTR(Break)

// Loads the value of D (interpreted as a signed int16) in register A
AD_INSTR(StoreSmallInt) // Can this work with signed ints too?

// Arithmetic : a = b (op) c. Result's type is the type of the operand.
ABC_INSTR(AddInt)     // Int Addition
ABC_INSTR(AddDouble)  // Double Addition
ABC_INSTR(SubInt)     // Int Substraction
ABC_INSTR(SubDouble)  // Double Substraction
ABC_INSTR(MulInt)     // Int Multiplication
ABC_INSTR(MulDouble)  // Double Multiplication
ABC_INSTR(DivInt)     // Int Division
ABC_INSTR(DivDouble)  // Double Division
ABC_INSTR(ModInt)     // Int Modulo
ABC_INSTR(ModDouble)  // Double Modulo
ABC_INSTR(PowInt)     // Int exponentiation
ABC_INSTR(PowDouble)  // Double exponentiation

// Comparisons a = b (cond) c. Result is always an int (1 for true, 0 for false)
ABC_INSTR(EqInt)      // Int Equality
ABC_INSTR(LEInt)      // Int Less or Equal
ABC_INSTR(LTInt)      // Int Less Than
ABC_INSTR(EqDouble)   // Double Equality
ABC_INSTR(LEDouble)   // Double Less or Equal
ABC_INSTR(LTDouble)   // Double Less Than
ABC_INSTR(GEDouble)   // Double Greater or Equal
ABC_INSTR(GTDouble)   // Double Greater Than

// Other arithmetic/logic ops that operate on raw values
AB_INSTR(LNot)        // Logical NOT
ABC_INSTR(LOr)        // Logical OR
ABC_INSTR(LAnd)       // Logical AND

LAST_INSTR(LAnd)

//----------------------------------------------------------------------------//

#undef INSTR
#undef SIMPLE_INSTR
#undef ABC_INSTR
#undef AB_INSTR
#undef AD_INSTR
#undef LAST_INSTR