//----------------------------------------------------------------------------//
// This file is part of the Fox project.        
// See the LICENSE.txt file at the root of the project for license information.            
// File : Instructions.def                      
// Author : Pierre van Houtryve                
//----------------------------------------------------------------------------//
// This file uses Macro to "register" every bytecode instruction 
// supported by the Fox VM.
//----------------------------------------------------------------------------//
/*
  TODO: Rewrite doc
*/
//----------------------------------------------------------------------------//

#ifndef INSTR
  #define INSTR(ID)
#endif

#ifndef LAST_INSTR
  #define LAST_INSTR(ID)
#endif

#ifndef SIMPLE_INSTR
  #define SIMPLE_INSTR(ID) INSTR(ID)
#endif

#ifndef TERNARY_INSTR
  #define TERNARY_INSTR(ID, T1, T2, T3) INSTR(ID)
#endif

#ifndef BINARY_INSTR
  #define BINARY_INSTR(ID, T1, T2) INSTR(ID)
#endif

#ifndef UNARY_INSTR
  #define UNARY_INSTR(ID, T1) INSTR(ID)
#endif

#ifndef TAC_INSTR
  #define TAC_INSTR(ID) TERNARY_INSTR(ID, std::uint8_t, std::uint8_t, std::uint8_t)
#endif

//----------------------------------------------------------------------------//

SIMPLE_INSTR(NoOp)
SIMPLE_INSTR(Break)

// Stores D (a signed 16 bit int) in register A
BINARY_INSTR(StoreSmallInt, std::uint8_t, std::int16_t)

// Arithmetic : a = b (op) c. Result's type is the type of the operand.
TAC_INSTR(AddInt)     // Int Addition
TAC_INSTR(AddDouble)  // Double Addition
TAC_INSTR(SubInt)     // Int Substraction
TAC_INSTR(SubDouble)  // Double Substraction
TAC_INSTR(MulInt)     // Int Multiplication
TAC_INSTR(MulDouble)  // Double Multiplication
TAC_INSTR(DivInt)     // Int Division
TAC_INSTR(DivDouble)  // Double Division
TAC_INSTR(ModInt)     // Int Modulo
TAC_INSTR(ModDouble)  // Double Modulo
TAC_INSTR(PowInt)     // Int exponentiation
TAC_INSTR(PowDouble)  // Double exponentiation

// Comparisons a = b (cond) c. Result is always an int (1 for true, 0 for false)
TAC_INSTR(EqInt)      // Int Equality
TAC_INSTR(LEInt)      // Int Less or Equal
TAC_INSTR(LTInt)      // Int Less Than (Is it needed?)
TAC_INSTR(EqDouble)   // Double Equality
TAC_INSTR(LEDouble)   // Double Less or Equal
TAC_INSTR(LTDouble)   // Double Less Than
TAC_INSTR(GEDouble)   // Double Greater or Equal
TAC_INSTR(GTDouble)   // Double Greater Than

// Other arithmetic/logic ops that operate on raw values
TAC_INSTR(LAnd)   // Logical AND
TAC_INSTR(LOr)    // Logical OR
BINARY_INSTR(LNot, std::uint8_t, std::uint8_t) // Logical NOT

// Jumps
BINARY_INSTR(CondJump, std::uint8_t, std::int16_t)  // Conditional Jump : Jump iff register != 0
UNARY_INSTR(Jump, std::int16_t)                     // Unconditional Jump

LAST_INSTR(Jump)

//----------------------------------------------------------------------------//

#undef INSTR
#undef SIMPLE_INSTR
#undef TERNARY_INSTR
#undef BINARY_INSTR
#undef UNARY_INSTR
#undef TAC_INSTR
#undef LAST_INSTR