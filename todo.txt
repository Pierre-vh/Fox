TODO:
> AST 2.0
	> ASTUnit : Represents a source file, contains declarations. (Done)
	> IdentifierTable & IdentifierInfo (Done)
	> ASTContext (Done)
	> Move stuf to /Fox/Basic (Done)
	> ASTContext : Types (Done)
	> New type system & deletion of /Common/Types (Done!)
	> Replace strings in the AST by IdentifierInfo* pointers (Done)	
	> ParsingResult rework (Done)
	> AST Improvements (Done)
	> Add ASTContext,parser & ast support for arrays types & Array literals. (Done)
	> Parser recovery improvements part 1(Done)

	> Parser recovery improvements part 2 :
		> Stop using ParsingRecoveryNode, do it more cleanly
			For Expr, use a new "ASTNullExpr" node.
			For Stmt, Create an "ASTNullStmt" if recovery was possible but we can't return anything useful. For while/ifs -> create a cond/loop node with a ASTNullExpr and a ASTNullStmt
			For Decls, add "isValid" functions to the base Decl class, this function checks that a declaration is valid and can be used.
		> Analyze every single parsing function to take advantage of new recovery techniques
			> Never return "not found" if we matched some tokens and modified the state. Always return an error if no recovery, and a partial node/recovery node if recovered.
			> If a function uses a "mandatory = true" parameter, it might be a good idea to try to recover to the last expected token (e.g ')'), if it works, return a empty node.
			  if it doesn't , backtrack and return an error.
			> If a nonterminal resyncs to a token but can't continue, return a recovery node or a partially-formed node.
		> Write test files and save them in a /res/ folder or something, each test showcases a common error problem. Run each of them in the command line toy to see if the parser handles it nicely.
			> Bonus points : give the Driver a special command to run each of them. e.g. "run-error-test-files"
		> Once that's done, we got 3 out of 4 suggestions for recovery down ! Write a nice doc explaining
		  how the parser reacts to missing token in various circumstances and how it deals with it.

	> DeclContext : ASTDecl abstract node wrapper around std::map<IdentifierInfo*,ASTDecl*>
		> Add it on nodes that need it (funcdecl,if/else/,loops,unit)
		> Lookup system with "restrictedLookup" (only this declcontext) and "fullLookup" call upper declcontexts to lookup and add lookupresults
		> For the lookup system, I'll need "LookupResult" class that wraps around an array of std::pair<IdentifierInfo*,IASTDecl*> for all matching decls.
	> DeclRef nodes : getDecl(), hasBeenLinkedToDeclaration(), etc.

	> At this point if nothing caught fire, write unit tests to catch bugs and make things catch fire.
		> Test DeclContext chaining : Does it work correctly?
		> Type tests ? (Like, try to identify types by comparing ASTContext pointers, etc)
		> Does lookup work as intended 
		> Uniqueness of identifiers (Done)
		> Try to break stuff with edge cases.

	> Visitor System rework, inspired by CLang/Swift.
		> ASTVisitor (class that visits a tree however it likes to)
		> Maybe an ASTWalker. It would be quite handy for Dumper and to create a Constant Folding visitor. 
			See Swift's impl
				https://github.com/apple/swift/blob/master/include/swift/AST/ASTWalker.h
				https://github.com/apple/swift/blob/master/lib/AST/ASTWalker.cpp
				It's quite complicated, maybe a simplified version would work.
	> Delete old ASTVisitor & Dumper 
	> Rewrite dumper under the new system
	> Write tests for the new visitor system

> Sourceloc system
	> SourceManager (a simple class that keeps track of source file contents and assigns an ID to them.)
		> addFromFile() 
		> addFromString() 
			>	both of theses 2 functions will return a lightweight "Response", with a status indicating if the operation was a success and the index
				of the source in the sourcemanager's internal vector
		> getSourceForID() (do not return a copy of the source, but a reference/pointer)
	> SourceLoc object
		> Current idea : store the ID + a uint32_t for the character index.
	> SourceRange 
		a Sourceloc + an offset (uint16)
	> Update lexer to add a sourcerange/loc to every single token
	> Update ast so all nodes have a sourceloc/range too !
	> Update Diagnostics & DiagnosticsEngine to support a sourceloc/sourcerange arg.
> Write all the remaining tests needed.

> Move all of my current diagnostics message to the new system.
> Delete the context's system primitive diag system.

> Semantic Analysis time ! It's going to be fun (or not :) ) !