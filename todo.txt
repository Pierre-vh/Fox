TODO:
> AST 2.0
	> ASTUnit : Represents a source file, contains declarations. (Done)
	> IdentifierTable & IdentifierInfo (Done)
	> ASTContext (Done)
	> Move stuf to /Fox/Basic (Done)
	> ASTContext : Types (Done)
	> New type system & deletion of /Common/Types (Done!)
	> Replace strings in the AST by IdentifierInfo* pointers (Done)	
	> ParsingResult rework (Done)
	> AST Improvements (Done)
	> Add ASTContext,parser & ast support for arrays types & Array literals. (Done)
	> Parser recovery improvements part 1(Done)
	> Parser recovery improvements part 2 (Done)
	> Parser recovery improvements part 3 : Reworked it entirely again! (Done)
	> Parsing Result Rework & Parser Improvements Part 4 : Final part (Done)
	> Create a "DeclarationRecorder", which is a wrapper around a std::multimap<IdentifierInfo*,ASTNamedDecl*> (Done)
	> Parser support for DeclRecorder with a RAIIContext object. (Done)
	> UniquePtrVector & DereferenceIterators + Minimizing interaction with unique pointers for AST Visitors(Done)
	> Major AST "Cleanup" in preparation for Visitor pattern rework (Done)
	> Write more Unit tests (Done)
	> Visitor system rework (Done)
	> Delete old ASTVisitor & Dumper  (Done)
	> Rewrite dumper under the new system	(Done)

	> Do some polish on ASTDumper. (Done? Will still come back to that from time to time!)
	> Make "MapDataIterator" work (next)
	> Write tests for the new visitor system (Do more of them)

> Sourceloc system
	> SourceManager (a simple class that keeps track of source file contents and assigns an ID to them.)
		> readSourceFromFile() 
		> addSourceFromString() 
			> Both of theses 2 functions will return a FileID. The FileID is invalid if the operation failed.
			> To mark a FileID as invalid, set it to std::numeric_limits<uint16_t>::max()
		> getSourceForID() (do not return a copy of the source, but a reference to it)
			> Whenever this is used, it should be ensured that no copies of the string are made, only references are taken! This mostly concerns the Lexer: store a reference to a std::string internally, not a vanilla std::string!
	> SourceLoc object
		> Current idea : store the ID (int16) + a int32 for the character index.
	> SourceRange 
		a Sourceloc + an offset (uint16), or just a pair for sourcelocs.
	> Update lexer to add a sourcerange/loc to every single token
	> Update ast so all nodes have a sourceloc/range too (Will be needed, with great details, like the pos of { and } for the CP statement, etc)
	> Update Diagnostics & DiagnosticsEngine to support a sourceloc/sourcerange arg for EVERY diagnostic.

> Write tests for this new system

> Modify the Parser so it supports sourcelocs and sourceranges.
> Move all of my current diagnostics message to the new system.
> Delete the Context's system primitive diag system.

> Semantic Analysis.
	> Sema class
	> ExprSema
		> ExprEnvironement
	> DeclSema
		> Scopes
	> StmtSema
	> Currently, no "TypeSema" because most types are trivial enough (only primitive types & arrays). They don't need over-complicated analysis.