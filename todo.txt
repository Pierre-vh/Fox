TODO:
> AST 2.0
	> ASTUnit : Represents a source file, contains declarations. (Done)
	> IdentifierTable & IdentifierInfo (Done)
	> ASTContext (Done)
	> Move stuf to /Fox/Basic (Done)
	> ASTContext : Types (Done)
	> New type system & deletion of /Common/Types (Done!)
	> Replace strings in the AST by IdentifierInfo* pointers (Done)	
	> ParsingResult rework (Done)

	> Add ASTContext,parser & ast support for arrays types & Array literals. (next)
		> ASTContext needs a way to "register" and unique' array types, like in a set.
			> Find a way to make array types unique. Possibly create an helper class that wraps around a std::map<type*,std::unique_ptr<ArrayType>> to make code cleaner
				within the astcontext.
		>  Parser needs modification for <type> rule, it needs to be replaced, and the old <type> will be renamed to <typename>
			<typename> = "int" |  "float" | "char" | "bool" | "string"
			<type> = <typename> { '[' ']' }0+
		>  AST needs an ArrayLiteral that wraps around an expressionlist.
			> Note, arrayLiteral's type will be deduced by the typechecker.
		> Change ast ArrayAccess to accept expressions and not only declrefs
		> Change grammar of expressions to :	
			<primitive_literal>	= One literal of the following type : Integer, Floating-point, Boolean, String, Char
			<array_literal>		= '[' [<expr_list>] ']'
			<literal>			= <primitive_literal> | <array_literal>

			<decl_call>		= <id> [ <parens_expr_list> ]
			<primary>		= <literal> | <parens_expr> | <decl_call>
			<array_access>	= <primary> {'[' <expr> ']'}
			<member_access>	= <array_access> { '.' <decl_call> }

			This allows expressions of the form [1,2,3][0] // prints 1
				However, I fear that this might create some ambiguities with the arrayaccess operator, even if it shouldn't
				some tests might be welcome!

	> Change AST Hierarchy to make it more expressive.
		This needs to be done prior to the visitor rework and semantic analysis implementation.
		> Types 
			> Add "BuiltinType" base class for all current types
			> Rethink what the Type base class needs. 
				abstract "getString" function
				a isPrimitive function that checks if it's a primitive using static_cast<PrimitiveType*>(this);
				a isBuiltin function that works the same as isPrimitive
				etc.

			> Add "NamedDecl" node as base class of ASTFunctionDecl and ASTVarDecl
				has function like getDeclIdentifier()
			
			> See if ASTExpr & ASTStmt could use more nodes, but I don't think they need that.

			> Change the way ASTFuncDecl stores the args by adding a "ASTFunctionArgDecl" node, so each arg has it's own declaration, which will be
			  useful to register function args in a declcontext.
			  The ASTFunctionDecl will store a vector of theses as childrens.

			> Globally, take a long look at my current ASTStructure to see what could be improved.

	> DeclContext : std::map<IdentifierInfo*,IASTDecl*>
		> Add it on nodes that need it (funcdecl,if/else/,loops,unit)
		> Lookup system with "restrictedLookup" (only this declcontext) and "fullLookup" call upper declcontexts to lookup and add lookupresults
		> For the lookup system, I'll need "LookupResult" class that wraps around an array of std::pair<IdentifierInfo*,IASTDecl*> for all matching decls.
	> DeclRef nodes : getDecl(), hasBeenLinkedToDeclaration(), etc.

	> At this point if nothing caught fire, write unit tests to catch bugs and make things catch fire.
		> Test DeclContext chaining : Does it work correctly?
		> Type tests ? (Like, try to identify types by comparing ASTContext pointers, etc)
		> Does lookup work as intended 
		> Uniqueness of identifiers (Done)
		> Try to break stuff with edge cases.

	> Visitor System rework, inspired by CLang/Swift.
		> ASTVisitor (class that visits a tree however it likes to)
		> Maybe an ASTWalker. It would be quite handy for Dumper and to create a Constant Folding visitor. 
			See Swift's impl
				https://github.com/apple/swift/blob/master/include/swift/AST/ASTWalker.h
				https://github.com/apple/swift/blob/master/lib/AST/ASTWalker.cpp
				It's quite complicated, maybe a simplified version would work.
	> Delete old ASTVisitor & Dumper 
	> Rewrite dumper under the new system
	> Write tests for the new visitor system

> Sourceloc system
	> SourceManager (a simple class that keeps track of source file contents and assigns an ID to them.)
		> addFromFile() 
		> addFromString() 
			>	both of theses 2 functions will return a lightweight "Response", with a status indicating if the operation was a success and the index
				of the source in the sourcemanager's internal vector
		> getSourceForID() (do not return a copy of the source, but a reference/pointer)
	> SourceLoc object
		> Current idea : store the ID + a uint32_t for the character index.
	> SourceRange 
		a Sourceloc + an offset (uint16)
	> Update lexer to add a sourcerange/loc to every single token
	> Update ast so all nodes have a sourceloc/range too !
	> Update Diagnostics & DiagnosticsEngine to support a sourceloc/sourcerange arg.
> Write all the remaining tests needed.

> Move all of my current diagnostics message to the new system.
> Delete the context's system primitive diag system.

> Semantic Analysis time ! It's going to be fun (or not :) ) !