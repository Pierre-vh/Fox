Moonshot Project To-do List.
	> ASTUnit : Represents a source file, contains declarations. (Done)
	> IdentifierTable & IdentifierInfo (Done)
	> ASTContext (Done)
	> Move stuf to /Fox/Basic (Done)
	> ASTContext : Types (Done)
	> New type system & deletion of /Common/Types (Done!)
	> Replace strings in the AST by IdentifierInfo* pointers (Done)	
	> ParsingResult rework (Done)
	> AST Improvements (Done)
	> Add ASTContext,parser & ast support for arrays types & Array literals. (Done)
	> Parser recovery improvements part 1(Done)
	> Parser recovery improvements part 2 (Done)
	> Parser recovery improvements part 3 : Reworked it entirely again! (Done)
	> Parsing Result Rework & Parser Improvements Part 4 : Final part (Done)
	> Create a "DeclarationRecorder", which is a wrapper around a std::multimap<IdentifierInfo*,ASTNamedDecl*> (Done)
	> Parser support for DeclRecorder with a RAIIContext object. (Done)
	> UniquePtrVector & DereferenceIterators + Minimizing interaction with unique pointers for AST Visitors(Done)
	> Major AST "Cleanup" in preparation for Visitor pattern rework (Done)
	> Write more Unit tests (Done)
	> Visitor system rework (Done)
	> Delete old ASTVisitor & Dumper  (Done)
	> Rewrite dumper under the new system	(Done)
	> Make "MapDataIterator" work (Done)
	> Do some polish on ASTDumper. Right now the dump is a bit rough to read, maybe try to make it prettier, or let the user enable/disable some informations? (Done? Will come back to that from time to time)
	> Write tests for the new visitor system (I'll do more when needed)
	> Sourceloc & SourceManager system (Done)
	> Update lexer/token to add a sourcerange/loc to every single token (Done)
	> Update the Parser so it can return more SourceLoc info. (Done)
	> Update the AST so all nodes have a sourceloc/range too wherever needed. (Done)
	> Write Decl Locs Test (Done)
	> First AST Code Review (Done)
	> Remove "Fake" Recovery nodes in the AST and find a proper, better solution to this problem. (Done, could use improvements later but for now we're good!)

	> Write Stmt & Expr Loc Tests (Next)

	> Write an ASTValidator and ASTRecursiveValidator that "validates" nodes (checks if they're complete) 
		> This will be used to check the AST after the parsing phase. It's a visitor that will just return a boolean. True and the AST is valid, false and it's not.
		  exemple usage will be "if(!astvalidator.visit(unit)) return;"
		  This will also be added to all parser tests as a post parsing check to ensure that the generated trees are safe.


	> Update Diagnostics & DiagnosticsEngine to support a SourceRange/SourceLoc arg
		> 2 Variants should exist :
			> One that report an error
			> One that report an error at a loc/range (sets the caret)

	> The DiagnosticConsumer should always try to retrieve the line where the error happened, displaying '^^^^' under the place
	  the error is.

	> Write all the remaining tests needed.

	> Move all of my current diagnostics message to the new system.
	> Delete the context's system primitive diag system.

	> Delete the Context. It'll be effectively useless after
		> To be defined :
			> How to determine if we can advance to the next compilation stage?
				> At first, use ASTValidator
				> See Semantic Analysis notes for final solution

	> Test the new diag system a bit more, if possible.	

	> Small update to SourceManager:
		Rename SourceManager.hpp/.cpp to Source.hpp/.cpp
		Rework the PreciseLoc algorithm : cache a "line table" and use it

	> Reevaluate the need for RTTI inside the project. Since i'm already half in LLVM coding styles,
	  maybe remove it an use a llvm style completely : implement a dyn_cast & isa operation + classof methods.
	  That way I might gain performance + the style will be consistent with LLVM's/CLang's
	  Relevant code samples:
		#define EXPR_RANGE(Id, FirstId, LastId) \
		First_##Id##Expr = FirstId, Last_##Id##Expr = LastId,

	  This shouldn't be too hard to do, maybe it'll take an afternoon?

	// Move to 0.3.0

	After that:
		> Semantic Analysis
			> Semantic Analysis should check for each node it's validity using the Validator.
		      a typical Sema function should look like this for almost every node. The  proper analysis is then done by the Decl/Stmt/Expr checker.
			  (e.g. for a Decl) 
			  if(!Validator.visit(node))
				{
					diagnoseIncompleteDecl(node);
					return;
				}
			  
			  DeclChecker.visit(node);
					
		> Lexer Rework
			> Make the Lexer & Parser tightly coupled.
			> Don't use the vectors anymore (to save memory)
			> Stop using a DFA. Use a proper grammar with a recursive descent technique
			  and a config file (.def) to register valid terminals

