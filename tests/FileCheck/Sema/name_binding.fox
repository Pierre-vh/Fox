// RUN: %fox-dump-ast | %filecheck

//----------------------------------------------------------------------------//
// Test name binding to variables in global scope
//----------------------------------------------------------------------------//

func some_func_before() {}

// CHECK: VarDecl [[global_a_addr:0x([[:alnum:]]{8,16})]] {{.*}} let a 'int'
let a : int;
// CHECK-NEXT: VarDecl [[global_b_addr:0x([[:alnum:]]{8,16})]] {{.*}} var b 'double'
var b : double;

// CHECK-NEXT: FuncDecl [[foo_addr:0x([[:alnum:]]{8,16})]] {{.*}} foo '(char,[string]) -> int'
// CHECK-NEXT: ParamDecl [[param_a_addr:0x([[:alnum:]]{8,16})]] {{.*}} a 'char'
// CHECK-NEXT: ParamDecl [[mutParam_addr:0x([[:alnum:]]{8,16})]] {{.*}} mut mutParam '[string]'
func foo(a : char, mutParam : mut [string]) : int {
  // CHECK: DeclRefExpr 'char' a <decl:[[param_a_addr]]>
  a;
  // Check that a reference to a mutable variable has a "lvalue"
  // CHECK: DeclRefExpr lvalue 'double' b <decl:[[global_b_addr]]>
  b;
  // CHECK: DeclRefExpr lvalue '[string]' mutParam <decl:[[mutParam_addr]]>
  mutParam;
  // CHECK-NEXT: DeclRefExpr '(char,[string]) -> int' foo <decl:[[foo_addr]]>
  foo;
  // CHECK-NEXT: DeclRefExpr '[double]' c
  c;
  // CHECK-NEXT: DeclRefExpr '() -> void' some_func_before
  some_func_before;
  // CHECK-NEXT: DeclRefExpr '([bool],string) -> char' another_func_after
  another_func_after;
}

// CHECK: VarDecl {{0x([[:alnum:]]{8,16}) .*}} let c '[double]'
// CHECK: DeclRefExpr 'int' a <decl:[[global_a_addr]]>
let c : [double] = [a as double];

func another_func_after(baz: [bool], foz: string) : char{}