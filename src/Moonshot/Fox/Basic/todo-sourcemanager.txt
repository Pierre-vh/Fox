This file describes what needs to be done for the SourceManager system:

// FileID struct/class
	// Wrapper around a 16 bit unsigned integer (an index) that locates a File inside the source manager.
		// 0 = Invalid
		// >0 = Valid file

// SourceFile struct/class
	// Class that contains information about a source file 
		// if the source file comes from the disk:
			// File path
			// File Name 
		// Else : return "" when getters/setters are called
		// File content
			// for the file content, getters/Setters return a reference to the string, and not the string itself, to avoid copies.

// SourceManager
	// Wrapper around a std::map<FileID,SourceFile>
	// Provides helper functions :
		// const SourceFile* getFile(FileID) 
			// Quick reflexion : use a pointer or a reference ? Or even, an iterator? See https://stackoverflow.com/a/516041
			// This says that a wrapper around an interator is the safest thing to do. Maybe pack in a end_ iterator in it too to check if the file's valid
			// with operator bool();
			// This ensures total safety/validity of the pointer, and can also be helpful to check it's validity. 
		// FileID addFileFromDisk(std::string filepath) // Returns the fileID of the newly registered file.
		// FileID addFileFromString(std::string string) // same as above
		// etc... as needed.

// SourceLoc
	// A Small struct used to locate a character in a SourceFile hosted by the SourceManager
	// std::size_t idx -> index of the char (use StringManipulator::advance to get to it)
	// FileID fileId -> id of the file.

Last note: update the StringManipulator so it doesn't copy the string it's manipulating if a pointer is passed to it. (DONE!)
	This was needed so when manipulating a file, a copy isn't performed.
	I'm a bit concerned about memory efficiency. Not that much, but I avoid copies of large objects at all costs, because Moonshot is designed
	to be embeddable, and I don't want that my interpreter becomes a burden on the user by being a memory eating machine. Of course, later, I'll provide
	a mechanism to serialize IR to a file, so when shipping a large number of source files you can precompile them and reduce memory usage & load times by a ton!
	(Because the serialized IR will already be optimized, there will be no need to perform lexing/parsing/semantic analysis on it, just run & execute!);